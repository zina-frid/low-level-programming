[31] T 125[<end>] S [Конец программы]
[32] X 0 S
[33] T 0 S [acc = 0]
[34] A 84 [<adrr> len A] S [acc = len A]
[35] T 1 S [1 = acc = len A, acc = 0]
[36] A 85 [<adrr> len B] S [acc = len B]
[37] T 2 S [2 = acc = len B, acc = 0]
[38] A 86 [<adrr> len R] S [acc = len R]
[39] T 3 S [3 = acc = len R, acc = 0]
[loop:]
[40] [r1] A  96 [<adrr> A(i)] S [ acc = A(i)]
[41] T 4 S [4 = acc = A(i), acc = 0]
[42] [r2] A 97 [adrr B(j)] S
[43] U 5 S [5 = acc = B(j)]
[44] S 4 [A(i)] S [ Acc = B(j) -  A(i)]
[45] E 59 [X] S [if B(j) > A(i) goto <X>]

[else:]
[46] T 0 S [acc = 0]
[47] A 5 S [acc = B(j)]
[48] T 6 S [6 = acc = B(j), acc = 0]

[49] A 2 S [загружаем счетчик необработанных элементов массива B]
[50] S 83 [two] S [уменьшаем на 2]
[51] G 57 S [если результат < 0, не меняем r2, но печатаем B(j)]
[52] T 2 S [j = j - 2]

[53] A 83 [two] S [загрузка в аккумулятор константы 2]
[54] L 0 L [сдвиг на 1 разряд влево]
[55] A 42 [r2] S [прибавляем код инструкции, исполненной на предыдущем шаге]
[56] T 42 [r2] S [записываем сформированную инструкцию в память]

[57] A 6 S [acc = 6 = B(j)]
[58] E 72 [Y] S [goto Y]

[X:]
[59] T 0 S [acc = 0]
[60] A 4 S [acc = A(i)]
[61] T 6 S [6 = acc = A(i), acc = 0]

[62] A 1 S [загружаем счетчик необработанных элементов массива A]
[63] S 83 [two] S [уменьшаем на 2]
[64] G 70 S [если результат < 0, не меняем r1, но печатаем A(j)]
[65] T 1 S [i = i - 2]

[66] A 83 [two] S [загрузка в аккумулятор константы 2]
[67] L 0 L [сдвиг на 1 разряд влево ]
[68] A 40 [r1] S [прибавляем код инструкции, исполненной на предыдущем шаге]
[69] T 40 [r1] S [записываем сформированную инструкцию в память]

[70] A 6 S [acc = 6 = A(j)]
[71] E 72 [Y] S [goto Y]

[Y:]
[72] [w3] T 109 [adrr R(k)] S [R(k) = acc, acc = 0]
[73] A 3 S [загружаем счетчик необработанных элементов массива R]
[74] S 83 [two] S [уменьшаем на 2]
[75] G 82 [<exit>] S [если результат < 0, завершаем работу]
[76] T 3 S [k = k - 2]

[77] A 83 [two] S [загрузка в аккумулятор константы 2]
[78] L 0 L [сдвиг на 1 разряд влево]
[79] A 72 [w3] S [прибавляем код инструкции, исполненной на предыдущем шаге]
[80] T 72 [w3] S [записываем сформированную инструкцию в память]

[81] E 40[<loop>] S
[82] [exit] Z 0 S [останов]

[83] [two] P 1 S [const 2]
[84] [len A] P 5 S [= len A * 2 = 10, т.к. через 2]
[85] [len B] P 4 S  [= len B * 2 = 8, т.к. через 2]
[86] [len R] P 8 S  [= (len A + len B - 1) * 2 = 16, т.к. через 2]

[87] P 0 S
[88] P 0 S
[89] P 0 S
[90] P 0 S
[91] P 0 S [Для того, чтобы все массивы были на Long Tank 3]
[92] P 0 S
[93] P 0 S
[94] P 0 S
[95] P 0 S

[Array A]  [Через один для наглядности]
[Array B]

[96]  [A] P 7 S    [14]
[97]  [B] P 31 S   [62]
[98]  [A] P 127 S  [254]
[99]  [B] P 127 S  [254]
[100] [A] P 255 S  [510]
[101] [B] P 511 S  [1022]
[102] [A] P 1023 S [2046]
[103] [B] P 2047 S [4094]
[104] [A] P 4095 S [8190]

[105] P 0 S
[106] P 0 S  [Пробел между входными массивами и результатом]
[107] P 0 S

[Merged Array => M] [Через один для наглядности]
[Result Array => R]
[108] [M] P 7 S [14]
[109] [R] P 0 S
[110] [M] P 31 S [62]
[111] [R] P 0 S
[112] [M] P 127 S [254]
[113] [R] P 0 S
[114] [M] P 127 S [254]
[115] [R] P 0 S
[116] [M] P 255 S [510]
[117] [R] P 0 S
[118] [M] P 511 S [1022]
[119] [R] P 0 S
[120] [M] P 1023 S [2046]
[121] [R] P 0 S
[122] [M] P 2047 S [4094]
[123] [R] P 0 S
[124] [M] P 4095 S [8190]
