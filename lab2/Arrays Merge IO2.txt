[ПОДПРОГРАММА: ]
T 56 K [целевой адрес = 56]
G    K [ директива IO2, фиксация начального адреса подпрограммы ]

[ 0:] A 3 F [ пролог: формирование кода инструкции возврата в acc ]
[ 1:] T 44 [<ret>] @ [ пролог: запись инструкции возврата, acc = 0 ]

[loop:]
[ 2:] [r1] A 54 [<adrr> A(i)] @ [ acc = A(i)]
[ 3:] T 49 @ [4 = acc = A(i), acc = 0]
[ 4:] [r2] A 55 [adrr B(j)] @
[ 5:] U 50 @ [5 = acc = B(j)]
[ 6:] S 49 [A(i)] @ [ Acc = B(j) -  A(i)]
[ 7:] E 21 [X] @ [if B(j) > A(i) goto <X>]

[else:] 
[ 8:] T 0 F [acc = 0]
[ 9:] A 50 @ [acc = B(j)]
[ 10:] T 51 @ [6 = acc = B(j), acc = 0]

[ 11:] A 47 @ [загружаем счетчик необработанных элементов массива B]
[ 12:] S 45 [two] @ [уменьшаем на 2]
[ 13:] G 19 @ [если результат < 0, не меняем r2, но печатаем B(j)]
[ 14:] T 47 @ [j = j - 2]

[ 15:] A 45 [two] @ [загрузка в аккумулятор константы 2]
[ 16:] L 0 D [сдвиг на 1 разряд влево]
[ 17:] A 4 [r2] @ [прибавляем код инструкции, исполненной на предыдущем
[ 18:] T 4 [r2] @ [записываем сформированную инструкцию в память]

[ 19:] A 51 @ [acc = 6 = B(j)]
[ 20:] E 34 [Y] @ [goto Y]

[X:]
[ 21:] T 0 F [acc = 0]
[ 22:] A 49 @ [acc = A(i)]
[ 23:] T 51 @ [6 = acc = A(i), acc = 0]

[ 24:] A 46 @ [загружаем счетчик необработанных элементов массива A]
[ 25:] S 45 [two] @ [уменьшаем на 2]
[ 26:] G 32 @ [если результат < 0, не меняем r1, но печатаем A(j)]
[ 27:] T 46 @ [i = i - 2]

[ 28:] A 45 [two] @ [загрузка в аккумулятор константы 2]
[ 29:] L 0 D [сдвиг на 1 разряд влево ]
[ 30:] A 2 [r1] @ [прибавляем код инструкции, исполненной на предыдущем шаге]
[ 31:] T 2 [r1] @ [записываем сформированную инструкцию в память]

[ 32:] A 51 @ [acc = 6 = A(j)]
[ 33:] E 34 [Y] @ [goto Y]

[Y:]
[ 34:] [w3] T 73 [adrr R(k)] @ [R(k) = acc, acc = 0]
[ 35:] A 48 @ [загружаем счетчик необработанных элементов массива R]
[ 36:] S 45 [two] @ [уменьшаем на 2]
[ 37:] G 44 [<exit>] @ [если результат < 0, завершаем работу]
[ 38:] T 48 @ [k = k - 2]

[ 39:] A 45 [two] @ [загрузка в аккумулятор константы 2]
[ 40:] L 0 D [сдвиг на 1 разряд влево]
[ 41:] A 34 [w3] @ [прибавляем код инструкции, исполненной на предыдущем шаге]
[ 42:] T 34 [w3] @ [записываем сформированную инструкцию в память]

[ 43:] E 2 [<loop>] @
[ 44:] [ret] E 0 F [эпилог: ипструкция возарата из подрограммы]

[ 45:] [two] P 1 F [const 2]
[ 46:] [len A] P 5 F [= len A * 2 = 10, т.к. через 2]
[ 47:] [len B] P 4 F  [= len B * 2 = 8, т.к. через 2]
[ 48:] [len R] P 8 F  [= (len A + len B - 1) * 2 = 16, т.к. через 2]

[ 49:] P 0 F [рабочая ячейка A]
[ 50:] P 0 F [рабочая ячейка B]
[ 51:] P 0 F [рабочая ячейка A или B]
[ 52:] P 0 F
[ 53:] P 0 F

[Array A]  [Через один для наглядности]
[Array B]
[ 54:] [A] P 7 F    [14]
[ 55:] [B] P 31 F   [62]
[ 56:] [A] P 127 F  [254]
[ 57:] [B] P 127 F  [254]
[ 58:] [A] P 255 F  [510]
[ 59:] [B] P 511 F  [1022]
[ 60:] [A] P 1023 F [2046]
[ 61:] [B] P 2047 F [4094]
[ 62:] [A] P 4095 F [8190]

[ 63:] P 0 F
[ 64:] P 0 F
[ 65:] P 0 F
[ 66:] P 0 F
[ 67:] P 0 F  [Для того, чтобы массивы]
[ 68:] P 0 F  [начинались на Long Tank 4]
[ 69:] P 0 F
[ 70:] P 0 F
[ 71:] P 0 F

[Merged Array => M] [Через один для наглядности]
[Result Array => R]
[ 72:] [M] P 7 F [14]
[ 73:] [R] P 0 F
[ 74:] [M] P 31 F [62]
[ 75:] [R] P 0 F
[ 76:] [M] P 127 F [254]
[ 77:] [R] P 0 F
[ 78:] [M] P 127 F [254]
[ 79:] [R] P 0 F
[ 80:] [M] P 255 F [510]
[ 81:] [R] P 0 F
[ 82:] [M] P 511 F [1022]
[ 83:] [R] P 0 F
[ 84:] [M] P 1023 F [2046]
[ 85:] [R] P 0 F
[ 86:] [M] P 2047 F [4094]
[ 87:] [R] P 0 F
[ 88:] [M] P 4095 F [8190]

[ТЕСТОВАЯ ПРОГРАММА: ]
      G   K   [Фиксация начального адреса программы]

[ 0:] A 0 @  [Вызов]
[ 1:] G 56 F [     подпрограммы]
[ 2:] Z 0 F  [Останов]

      EZ PF  [Переход к исполнению]
